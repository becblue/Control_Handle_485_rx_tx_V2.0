# ? STM32 双向通信控制系统 - 完整工作逻辑

## ? 项目总体架构

这是一个**工业远程控制系统**，包含两种完全不同的硬件设备：

1. **? 遥控手柄** (`DEVICE_MODE_SEND`) - 操作员控制端
2. **? 接收板** (`DEVICE_MODE_RECV`) - 现场执行端

两者通过 **RS485串口** 进行双向实时通信，实现远程设备控制。

### ?? 重要说明

- **相同的代码工程，编译两次生成两个固件**
- **两种硬件的PCB设计完全不同，不能互换！**
- 通过修改 `IOApp.h` 中的 `DEVICE_MODE` 宏来切换编译目标

### 当前配置状态

```c
// User/inc/IOApp.h 第6行
#define DEVICE_MODE    DEVICE_MODE_RECV  // 当前编译接收板固件
```

**配置选项**：
- `DEVICE_MODE_SEND = 0` → 编译遥控手柄固件
- `DEVICE_MODE_RECV = 1` → 编译接收板固件

### 通信参数

- **通信方式**：RS485 半双工
- **波特率**：115200 bps
- **数据格式**：8N1 (8数据位, 无校验, 1停止位)
- **数据周期**：50ms/次
- **校验方式**：Modbus CRC-16

---

## ? 硬件1：遥控手柄 (发送端)

### 硬件组成

```
遥控手柄硬件构成：
├─ 24路输入: 按键、开关、选择器
│   ├─ KEY1 (PC3): 功能按键，循环选择通道
│   ├─ KEY5 (PC7): 功能按键，循环选择模式
│   └─ 其他22路: 普通按键/开关输入
│
├─ 2路模拟输入: 摇杆/电位器
│   ├─ PA1: 摇杆X轴 / 电位器1 (12位ADC)
│   └─ PA2: 摇杆Y轴 / 电位器2 (12位ADC)
│
├─ 12路LED输出: 状态指示
│   ├─ PA0, PA3, PA4, PA5: 特殊LED (可闪烁)
│   └─ 其他8路: 普通LED指示
│
└─ 调试接口: USART3 (PB10-TX, PB11-RX)
```

### GPIO分配详情

#### 输入端口 (24路)

| GPIO | bit | 索引 | 硬件 | 功能 | 特殊说明 |
|------|-----|------|------|------|---------|
| PC3 | 0 | 0 | 功能按键 KEY1 | 循环选择bit0-3 | 按下后依次激活 |
| PC4 | 1 | 1 | 按键/开关 | 控制位1 | - |
| PC5 | 2 | 2 | 按键/开关 | 控制位2 | - |
| PC6 | 3 | 3 | 按键/开关 | 控制位3 | - |
| PC7 | 4 | 4 | 功能按键 KEY5 | 循环选择bit4-7 | 按下后依次激活 |
| PC8 | 5 | 5 | 按键/开关 | 控制位5 | - |
| PC9 | 6 | 6 | 按键/开关 | 控制位6 | - |
| PC10 | 7 | 7 | 按键/开关 | 控制位7 | - |
| PC11 | 8 | 8 | 按键/开关 | 控制位8 | - |
| PC12 | 9 | 9 | 按键/开关 | 控制位9 | - |
| PC13 | 10 | 10 | 按键/开关 | 控制位10 | - |
| PC14 | 11 | 11 | 按键/开关 | 控制位11 | - |
| PC15 | 12 | 12 | 按键/开关 | 控制位12 | - |
| PB0 | 13 | 13 | 使能开关 | 安全使能控制 | ?? 重要：联锁开关 |
| PB1 | 14 | 14 | 按键/开关 | 控制位14 | - |
| PB3 | 15 | 15 | 按键/开关 | 控制位15 | - |
| PB4 | 16 | 16 | 按键/开关 | 控制位16 | - |
| PB5 | 17 | 17 | 按键/开关 | 控制位17 | - |
| PB6 | 18 | 18 | 按键/开关 | 控制位18 | - |
| PB7 | 19 | 19 | 按键/开关 | 控制位19 | - |
| PB8 | 20 | 20 | 按键/开关 | 控制位20 | - |
| PB9 | 21 | 21 | 按键/开关 | 控制位21 | - |
| PB10 | 22 | 22 | 按键/开关 | 控制位22 | - |
| PB11 | 23 | 23 | 按键/开关 | 控制位23 | - |

**读取逻辑**：
```c
// 常规按键：低电平有效（按下=0，松开=1）
if(GPIO_ReadInputDataBit(...) == RESET && i>7) {
    result |= (0x01<<i);  // 按键按下时置位
}

// KEY1和KEY5特殊处理：通过软件循环控制bit0-7
```

#### 模拟输入 (2路)

| 通道 | GPIO | ADC通道 | 硬件 | 范围 | 分辨率 |
|------|------|---------|------|------|--------|
| 0 | PA1 | ADC1_CH1 | 摇杆X轴/电位器 | 0-3.3V | 12位 (0-4095) |
| 1 | PA2 | ADC1_CH2 | 摇杆Y轴/电位器 | 0-3.3V | 12位 (0-4095) |

**采集方式**：
- DMA自动搬运到 `AD_Value[2]` 数组
- 连续转换模式
- 采样时间：55.5个ADC周期

#### LED输出端口 (12路)

| GPIO | bit | 索引 | LED类型 | 功能 | 显示含义 |
|------|-----|------|---------|------|---------|
| PA0 | 0 | 0 | 特殊LED | 状态指示1 | 对应接收板反馈bit0 |
| PA3 | 1 | 1 | 特殊LED | 状态指示2 | 对应接收板反馈bit1 |
| PA4 | 2 | 2 | 特殊LED | 状态指示3 | 对应接收板反馈bit2 |
| PA5 | 3 | 3 | 特殊LED | 状态指示4 | 对应接收板反馈bit3 |
| PA6 | 4 | 4 | 普通LED | 状态指示5 | 对应接收板反馈bit4 |
| PA7 | 5 | 5 | 普通LED | 状态指示6 | 对应接收板反馈bit5 |
| PA8 | 6 | 6 | 普通LED | 状态指示7 | 对应接收板反馈bit6 |
| PA12 | 7 | 7 | 普通LED | 状态指示8 | 对应接收板反馈bit7 |
| PA15 | 8 | 8 | 普通LED | 状态指示9 | 对应接收板反馈bit8 |
| PC0 | 9 | 9 | 普通LED | 状态指示10 | 对应接收板反馈bit9 |
| PC1 | 10 | 10 | 普通LED | 状态指示11 | 对应接收板反馈bit10 |
| PC2 | 11 | 11 | 普通LED | 状态指示12 | 对应接收板反馈bit11 |

**LED控制逻辑**：

```c
PA0, PA3, PA4, PA5 (4个特殊LED):
┌─────────────────────────────────────────────────────┐
│ 接收板返回bit  │  手柄PB0状态  │  LED显示状态      │
├─────────────────────────────────────────────────────┤
│ 0 (未激活)     │  任意         │  灭 (低电平)      │
│ 1 (已激活)     │  0 (未按)     │  常亮 (高电平)    │
│ 1 (已激活)     │  1 (已按)     │  闪烁 (50ms周期)  │
└─────────────────────────────────────────────────────┘

PA6~PC2 (8个普通LED):
    直接根据接收板返回的bit4-11控制
    置位 → LED亮
    清零 → LED灭
```

### 遥控手柄工作流程

```
┌──────────────────────────────────────────────────────────────┐
│              ? 遥控手柄工作流程 (50ms周期)                   │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  ① 定时器触发 (每50ms)                                        │
│     └─ TIM2定时器 → TimUart1SendAlarm = true                 │
│                                                               │
│  ② 采集输入数据                                               │
│     ├─ 读取24路按键状态 (PC3-PC15, PB0-PB11)                 │
│     │   ├─ 常规按键：检测GPIO电平                            │
│     │   ├─ KEY1(PC3)：循环控制bit0-3                         │
│     │   │   └─ 1 → 2 → 4 → 8 → 0 (循环)                      │
│     │   └─ KEY5(PC7)：循环控制bit4-7                         │
│     │       └─ 0x10 → 0x20 → 0x40 → 0x80 → 0 (循环)         │
│     │                                                         │
│     └─ 读取2路ADC数据 (PA1, PA2)                             │
│         └─ DMA自动采集，12位精度 (0-4095)                    │
│                                                               │
│  ③ 数据打包 (14字节)                                         │
│     ├─ [0]: 帧头 0xAA                                        │
│     ├─ [1-3]: 24位按键状态 (3字节)                          │
│     ├─ [4-11]: 2路ADC数据 (8字节，每路重复2次)              │
│     └─ [12-13]: CRC校验码 (Modbus CRC-16)                   │
│                                                               │
│  ④ UART1发送数据                                             │
│     ├─ PA11置高 (RS485进入发送模式)                         │
│     ├─ 发送14字节数据包                                      │
│     └─ PA11置低 (RS485进入接收模式)                         │
│                                                               │
│  ⑤ 等待接收反馈 (异步)                                       │
│     └─ 超时时间：5ms字节间隔                                 │
│                                                               │
│  ⑥ 接收到反馈数据后 (中断触发)                               │
│     ├─ CRC校验                                               │
│     │   ├─ 通过 → 继续处理                                   │
│     │   └─ 失败 → 记录错误，等待下次                         │
│     │                                                         │
│     ├─ 解析反馈数据 (12位状态 + 8字节空数据)                 │
│     │   └─ bit0-11: 接收板返回的现场状态                     │
│     │                                                         │
│     └─ 更新LED显示                                           │
│         ├─ PA0,PA3,PA4,PA5 (特殊LED):                       │
│         │   └─ 根据反馈bit0-3 + 本地PB0状态决定              │
│         │       ├─ 闪烁 (反馈置位 + PB0置位)                 │
│         │       ├─ 常亮 (反馈置位 + PB0清零)                 │
│         │       └─ 灭 (反馈清零)                             │
│         │                                                     │
│         └─ PA6~PC2 (普通LED):                               │
│             └─ 直接根据反馈bit4-11控制                       │
│                                                               │
│  ⑦ 调试输出 (每500ms，通过USART3)                           │
│     ├─ 发送的数据包内容                                      │
│     ├─ 接收的反馈数据                                        │
│     ├─ CRC校验状态                                           │
│     └─ IO位详细解析                                          │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

### KEY1和KEY5功能详解

#### KEY1按键 (PC3)

**功能**：循环选择通道bit0-3

```c
静态变量: ShiftValue[0]

按键逻辑:
    首次按下: ShiftValue[0] = 0x01 (bit0置位)
    再次按下: ShiftValue[0] = 0x02 (bit1置位)
    再次按下: ShiftValue[0] = 0x04 (bit2置位)
    再次按下: ShiftValue[0] = 0x08 (bit3置位)
    再次按下: ShiftValue[0] = 0x00 (全部清零)
    循环...

作用:
    result = (result & ~0x0F) | ShiftValue[0];
    清除bit0-3，然后设置为选中的位
```

**应用场景**：
- 快速选择4个控制通道之一
- 避免同时激活多个通道
- 例如：控制4个方向（前/后/左/右）

#### KEY5按键 (PC7)

**功能**：循环选择通道bit4-7

```c
静态变量: ShiftValue[1]

按键逻辑:
    首次按下: ShiftValue[1] = 0x10 (bit4置位)
    再次按下: ShiftValue[1] = 0x20 (bit5置位)
    再次按下: ShiftValue[1] = 0x40 (bit6置位)
    再次按下: ShiftValue[1] = 0x80 (bit7置位)
    再次按下: ShiftValue[1] = 0x00 (全部清零)
    循环...

作用:
    result = (result & ~0xF0) | ShiftValue[1];
    清除bit4-7，然后设置为选中的位
```

**应用场景**：
- 快速选择4个模式之一
- 例如：速度档位（慢/中/快/超快）

### LED闪烁机制详解

**实现原理**：

```c
// 全局变量
uint16_t g_BlinkTimer = 0;          // 闪烁计时器 (0-49)
uint8_t g_BlinkState = 0;           // 闪烁状态 (0=灭, 1=亮)
uint8_t g_PA_BlinkEnable[4];        // 闪烁使能标志
uint8_t g_PA_NormalEnable[4];       // 常亮使能标志

// TIM2中断中 (每1ms执行一次)
void TIM2_IRQHandler(void) {
    g_BlinkTimer++;
    if(g_BlinkTimer >= 50) {        // 50ms到了
        g_BlinkTimer = 0;
        g_BlinkState = !g_BlinkState;  // 状态翻转 (0?1)
        PA_Blink_Process();            // 更新GPIO输出
    }
}

// GPIO更新函数
void PA_Blink_Process(void) {
    for(i = 0; i < 4; i++) {
        if(g_PA_BlinkEnable[i]) {
            // 闪烁模式：跟随g_BlinkState
            if(g_BlinkState) {
                GPIO_SetBits(...);     // 亮
            } else {
                GPIO_ResetBits(...);   // 灭
            }
        } else if(g_PA_NormalEnable[i]) {
            // 常亮模式
            GPIO_SetBits(...);
        } else {
            // 关闭
            GPIO_ResetBits(...);
        }
    }
}
```

**时序图**：

```
时间  0ms  50ms 100ms 150ms 200ms 250ms 300ms
     ┌────┬────┬─────┬─────┬─────┬─────┬─────┐
LED  │  │    │   │     │   │     │   │
状态 │ 亮 │ 灭 │ 亮  │ 灭  │ 亮  │ 灭  │ 亮  │
     └────┴────┴─────┴─────┴─────┴─────┴─────┘
闪烁频率: 10Hz (每秒闪烁10次)
占空比: 50%
```

---

## ? 硬件2：接收板 (接收端)

### 硬件组成

```
接收板硬件构成：
├─ 24路输出: 继电器、驱动器、执行器
│   ├─ PC3-PC6: 安全联锁输出 (需要PB0使能)
│   └─ 其他20路: 普通控制输出
│
├─ 2路模拟输出: DAC控制输出
│   ├─ 通道0: 正向输出 (0-10V)
│   └─ 通道1: 反向输出 (10-0V)
│
├─ 12路输入: 状态检测
│   ├─ 限位开关
│   ├─ 传感器信号
│   ├─ 设备反馈
│   └─ 安全信号
│
└─ 调试接口: USART3 (PB10-TX, PB11-RX)
```

### GPIO分配详情

#### 输出端口 (24路)

| GPIO | bit | 索引 | 硬件 | 功能 | 特殊控制 |
|------|-----|------|------|------|---------|
| PC3 | 0 | 0 | 继电器/驱动器 | 控制输出1 | ?? 需要PB0使能 |
| PC4 | 1 | 1 | 继电器/驱动器 | 控制输出2 | ?? 需要PB0使能 |
| PC5 | 2 | 2 | 继电器/驱动器 | 控制输出3 | ?? 需要PB0使能 |
| PC6 | 3 | 3 | 继电器/驱动器 | 控制输出4 | ?? 需要PB0使能 |
| PC7 | 4 | 4 | 继电器/驱动器 | 控制输出5 | 直接控制 |
| PC8 | 5 | 5 | 继电器/驱动器 | 控制输出6 | 直接控制 |
| PC9 | 6 | 6 | 继电器/驱动器 | 控制输出7 | 直接控制 |
| PC10 | 7 | 7 | 继电器/驱动器 | 控制输出8 | 直接控制 |
| PC11 | 8 | 8 | 继电器/驱动器 | 控制输出9 | 直接控制 |
| PC12 | 9 | 9 | 继电器/驱动器 | 控制输出10 | 直接控制 |
| PC13 | 10 | 10 | 继电器/驱动器 | 控制输出11 | 直接控制 |
| PC14 | 11 | 11 | 继电器/驱动器 | 控制输出12 | 直接控制 |
| PC15 | 12 | 12 | 继电器/驱动器 | 控制输出13 | 直接控制 |
| PB0 | 13 | 13 | 安全使能标志 | 联锁使能输入 | ?? 控制PC3-PC6 |
| PB1 | 14 | 14 | 继电器/驱动器 | 控制输出15 | 直接控制 |
| PB3 | 15 | 15 | 继电器/驱动器 | 控制输出16 | 直接控制 |
| PB4 | 16 | 16 | 继电器/驱动器 | 控制输出17 | 直接控制 |
| PB5 | 17 | 17 | 继电器/驱动器 | 控制输出18 | 直接控制 |
| PB6 | 18 | 18 | 继电器/驱动器 | 控制输出19 | 直接控制 |
| PB7 | 19 | 19 | 继电器/驱动器 | 控制输出20 | 直接控制 |
| PB8 | 20 | 20 | 继电器/驱动器 | 控制输出21 | 直接控制 |
| PB9 | 21 | 21 | 继电器/驱动器 | 控制输出22 | 直接控制 |
| PB10 | 22 | 22 | 继电器/驱动器 | 控制输出23 | 直接控制 |
| PB11 | 23 | 23 | 继电器/驱动器 | 控制输出24 | 直接控制 |

**安全联锁控制逻辑**：

```c
// PC3-PC6 (索引0-3) 特殊控制逻辑
for(i = 0; i <= 3; i++) {
    if((result & (0x01<<i)) &&        // 条件1: 对应命令位被置位
       (result & (0x01<<13))) {       // 条件2: PB0(bit13)也被置位
        GPIO_SetBits(...);             // 输出高电平
    } else {
        GPIO_ResetBits(...);           // 输出低电平
    }
}

// PC7-PC15, PB0-PB11 (索引4-23) 直接控制
for(i = 4; i < 24; i++) {
    if(result & (0x01<<i)) {
        GPIO_SetBits(...);
    } else {
        GPIO_ResetBits(...);
    }
}
```

**安全联锁真值表**：

| 命令bit0-3 | PB0(bit13) | PC3-PC6输出 | 说明 |
|-----------|-----------|------------|------|
| 0 | 0 | 低电平 | 命令未激活 |
| 0 | 1 | 低电平 | 命令未激活 |
| 1 | 0 | 低电平 | ?? 命令激活但PB0未使能 |
| 1 | 1 | 高电平 | ? 双重确认，允许输出 |

**应用场景**：
- 危险动作保护（重载升降、高速运动）
- 防止误操作
- 符合工业安全规范
- 实现双手操作模式

#### 模拟输出 (2路DAC)

| 通道 | GPIO | 芯片 | 输出范围 | 控制方式 |
|------|------|------|---------|---------|
| 0 | PB15(SYNC), PB13(CLK), PB14(DIN) | DAC7311 | 0-10V | 正向映射 |
| 1 | PD2(SYNC), PA1(CLK), PA2(DIN) | DAC7311 | 10-0V | 反向映射 |

**数据转换**：

```c
// 接收数据: ADC原始值 (0-4095) → 传输值 (0-3723)
// DAC输出: 传输值 (0-3723) → DAC数值 (0-2886) → 电压 (0-10V)

// 通道0 (正向)
InputValue = RxBuff[0]<<8 | RxBuff[1];        // 0-3723
OutputValue = (InputValue / 3723) * 2886;     // 线性映射
AO_output(0, OutputValue);

// 通道1 (反向)
InputValue = RxBuff[2]<<8 | RxBuff[3];        // 0-3723
InputValue = 3723 - InputValue;               // 翻转
OutputValue = (InputValue / 3723) * 2886;     // 线性映射
AO_output(1, OutputValue);
```

**为什么需要反向通道？**

1. **差分控制**：正向+反向 = 平衡控制
2. **镜像动作**：如双缸同步（一个伸出，一个缩回）
3. **阀门控制**：正向0-100%，反向100%-0%

#### 输入端口 (12路)

| GPIO | bit | 索引 | 硬件 | 功能 |
|------|-----|------|------|------|
| PA0 | 0 | 0 | 限位开关/传感器 | 状态检测1 |
| PA3 | 1 | 1 | 限位开关/传感器 | 状态检测2 |
| PA4 | 2 | 2 | 限位开关/传感器 | 状态检测3 |
| PA5 | 3 | 3 | 限位开关/传感器 | 状态检测4 |
| PA6 | 4 | 4 | 限位开关/传感器 | 状态检测5 |
| PA7 | 5 | 5 | 限位开关/传感器 | 状态检测6 |
| PA8 | 6 | 6 | 限位开关/传感器 | 状态检测7 |
| PA12 | 7 | 7 | 限位开关/传感器 | 状态检测8 |
| PA15 | 8 | 8 | 限位开关/传感器 | 状态检测9 |
| PC0 | 9 | 9 | 限位开关/传感器 | 状态检测10 |
| PC1 | 10 | 10 | 限位开关/传感器 | 状态检测11 |
| PC2 | 11 | 11 | 限位开关/传感器 | 状态检测12 |

**读取逻辑**：

```c
// 高电平有效（传感器触发=1，未触发=0）
if(GPIO_ReadInputDataBit(...) == SET) {
    result |= (0x01<<i);
}
```

**典型应用**：
- 限位开关（上限位、下限位、左限位、右限位）
- 到位传感器
- 急停按钮状态
- 门锁状态
- 故障信号
- 温度/压力报警

### 接收板工作流程

```
┌──────────────────────────────────────────────────────────────┐
│              ? 接收板工作流程 (事件驱动)                     │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  ① UART1接收中断触发                                         │
│     ├─ 检测帧头 0xAA                                         │
│     │   └─ 不是0xAA → 丢弃，重新开始                         │
│     ├─ 接收14字节数据                                        │
│     └─ 字节间隔超时5ms → 重新开始                            │
│                                                               │
│  ② 接收完成后 (主循环检测 Receive_Complete==1)               │
│     └─ 继续处理                                              │
│                                                               │
│  ③ CRC校验                                                   │
│     ├─ 计算接收数据的CRC (前12字节)                          │
│     ├─ 与接收的CRC比对 ([12][13]字节)                       │
│     │                                                         │
│     └─ 校验结果判断:                                         │
│         ├─ 成功 → 继续执行控制                               │
│         └─ 失败 → 丢弃数据，不执行任何控制                   │
│                                                               │
│  ④ 数据解析                                                  │
│     ├─ 解析24位控制命令 ([1][2][3]字节)                     │
│     │   └─ result = [1] + ([2]<<8) + ([3]<<16)              │
│     │                                                         │
│     └─ 解析2路模拟量数据 ([4-11]字节)                       │
│         ├─ 通道0: [4][5] (高字节在前)                       │
│         └─ 通道1: [8][9] (高字节在前)                       │
│                                                               │
│  ⑤ 保存原始命令 (用于状态反馈)                               │
│     └─ g_LastReceivedData = result;                          │
│                                                               │
│  ⑥ 输出控制执行                                              │
│     ├─ 数字输出 (24路):                                      │
│     │   ├─ PC3-PC6 (索引0-3):                               │
│     │   │   └─ if((bit置位) && (bit13置位))                 │
│     │   │       → 输出高电平                                │
│     │   │       else → 输出低电平                           │
│     │   │                                                    │
│     │   └─ 其他输出 (索引4-23):                             │
│     │       └─ 直接根据对应bit控制                          │
│     │                                                         │
│     └─ 模拟输出 (2路DAC):                                    │
│         ├─ 通道0: 正向线性输出                               │
│         └─ 通道1: 反向线性输出                               │
│                                                               │
│  ⑦ 读取本地输入状态                                          │
│     └─ 读取12路GPIO输入 (PA0,PA3-PA8,PA12,PA15,PC0-PC2)     │
│         └─ 高电平 → bit置位                                  │
│                                                               │
│  ⑧ 特殊处理：调整返回数据                                    │
│     ├─ bit0-3: 使用原始接收命令 (g_LastReceivedData)        │
│     │   └─ 原因：PC3-PC6有与逻辑，实际输出可能是低电平      │
│     │       但要让遥控手柄知道"命令已接收"                   │
│     │                                                         │
│     └─ bit4-11: 使用实际GPIO输入状态                         │
│                                                               │
│  ⑨ 打包状态反馈数据 (14字节)                                 │
│     ├─ [0]: 帧头 0xAA                                        │
│     ├─ [1-3]: 12位状态数据 (3字节)                          │
│     ├─ [4-11]: 空数据 (全0)                                 │
│     └─ [12-13]: CRC校验码                                   │
│                                                               │
│  ⑩ UART1发送状态反馈                                         │
│     ├─ PA11置高 (RS485进入发送模式)                         │
│     ├─ 发送14字节反馈包                                      │
│     └─ PA11置低 (RS485进入接收模式)                         │
│                                                               │
│  ? 清除接收完成标志                                          │
│     └─ Receive_Complete = 0;                                 │
│         等待下一次接收                                        │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

### 状态反馈特殊机制详解

**为什么bit0-3要返回原始命令而非实际输出状态？**

```
问题场景:
    遥控手柄发送: bit0=1, bit13(PB0)=0
    接收板逻辑: (bit0=1) && (bit13=0) → PC3输出低电平
    
如果返回实际输出状态:
    接收板返回: bit0=0 (因为PC3实际输出低电平)
    遥控手柄LED: 灭 (以为命令没有发送/接收)
    ? 问题: 操作员无法判断是命令没发送还是被联锁阻止了

实际返回原始命令:
    接收板返回: bit0=1 (原始命令)
    遥控手柄LED: 常亮 (因为PB0=0，不闪烁)
    ? 优点: 操作员知道命令已发送，但因为未按PB0所以未执行
```

**代码实现**：

```c
// IOApp.c

// 全局变量 (接收模式专用)
static uint32_t g_LastReceivedData = 0;

// 接收数据时保存原始命令
void IO_APP_Set_IO_Value(uint8_t * UartRxBuff) {
    result = UartRxBuff[0] + (UartRxBuff[1]<<8) + (UartRxBuff[2]<<16);
    g_LastReceivedData = result;  // 保存原始命令
    // ... 后续控制逻辑
}

// 准备反馈数据时调整bit0-3
void IO_APP_Get_IO_Value(uint8_t * UartTxBuff) {
    // 读取实际GPIO输入
    for(i=0; i<12; i++) {
        if(GPIO_ReadInputDataBit(...) == SET) {
            result |= (0x01<<i);
        }
    }
    
    // 替换bit0-3为原始命令
    result = result & 0xFFFFFFF0;              // 清除bit0-3
    result = result | (g_LastReceivedData & 0x0F);  // 设置为原始命令
    
    // bit4-11保持实际输入状态
    UartTxBuff[0] = (result>>0) & 0xFF;
    UartTxBuff[1] = (result>>8) & 0xFF;
    UartTxBuff[2] = (result>>16) & 0xFF;
}
```

---

## ? 完整通信流程图

```
                    遥控手柄端                          接收板端
                 (DEVICE_MODE_SEND)              (DEVICE_MODE_RECV)
                
T=0ms           采集24路按键
                采集2路ADC
                    ↓
T=1ms           打包14字节数据
                添加CRC校验
                    ↓
T=2ms           UART1发送 ──────────────→
                                               ↓
T=3ms                                      接收完成
                                           CRC校验
                                               ↓
T=4ms                                      解析命令
                                           保存原始命令
                                               ↓
T=5ms                                      执行输出控制:
                                           ├─ PC3-PC6: 与逻辑
                                           ├─ 其他IO: 直接控制
                                           └─ DAC: 模拟量输出
                                               ↓
T=6ms                                      读取12路输入
                                           调整bit0-3
                                               ↓
T=7ms                                      打包反馈数据
                                           添加CRC校验
                                               ↓
T=8ms                        ←──────────── UART1发送
                    ↓
T=9ms           接收反馈
                CRC校验
                    ↓
T=10ms          解析bit0-11
                    ↓
T=11ms          更新12路LED:
                ├─ PA0~PA5: 根据反馈+PB0
                └─ PA6~PC2: 直接显示
                    ↓
                    
────────────── 等待下一个50ms周期 ──────────────────

T=50ms          再次采集...
```

---

## ? 通信数据包详解

### 遥控手柄 → 接收板（控制命令包）

| 字节 | 内容 | 数据来源 | 说明 |
|------|------|---------|------|
| [0] | 0xAA | 固定值 | 帧头标识 |
| [1] | bit0-7 | PC3-PC10 | 按键状态低8位 |
| [2] | bit8-15 | PC11-PC15, PB0-PB2 | 按键状态中8位 |
| [3] | bit16-23 | PB3-PB11 | 按键状态高8位 |
| [4] | ADC1_H | PA1 ADC高字节 | 模拟量1高字节 |
| [5] | ADC1_L | PA1 ADC低字节 | 模拟量1低字节 |
| [6] | ADC1_H | PA1 ADC高字节 | 模拟量1重复 |
| [7] | ADC1_L | PA1 ADC低字节 | 模拟量1重复 |
| [8] | ADC2_H | PA2 ADC高字节 | 模拟量2高字节 |
| [9] | ADC2_L | PA2 ADC低字节 | 模拟量2低字节 |
| [10] | ADC2_H | PA2 ADC高字节 | 模拟量2重复 |
| [11] | ADC2_L | PA2 ADC低字节 | 模拟量2重复 |
| [12] | CRC_L | Modbus CRC-16 | CRC校验低字节 |
| [13] | CRC_H | Modbus CRC-16 | CRC校验高字节 |

**ADC数据为什么重复2次？**
- 提供数据冗余
- 增强可靠性
- 接收端可以比对两次数据是否一致

### 接收板 → 遥控手柄（状态反馈包）

| 字节 | 内容 | 数据来源 | 说明 |
|------|------|---------|------|
| [0] | 0xAA | 固定值 | 帧头标识 |
| [1] | bit0-7 | 特殊处理 | bit0-3=原始命令<br>bit4-7=PA6,PA7,PA8,PA12 |
| [2] | bit8-11 | PA15,PC0,PC1,PC2 | 状态输入bit8-11 |
| [3] | 0x00 | 空 | 保留字节 |
| [4-11] | 0x00 | 空 | 无模拟量数据 |
| [12] | CRC_L | Modbus CRC-16 | CRC校验低字节 |
| [13] | CRC_H | Modbus CRC-16 | CRC校验高字节 |

---

## ? 核心功能模块

### 1?? 定时器系统

#### TIM2硬件定时器

**配置参数**：
- **时钟源**：72MHz (系统时钟)
- **预分频器 (PSC)**：71 → 72MHz / 72 = 1MHz
- **自动重装载值 (ARR)**：999 → 1MHz / 1000 = 1kHz
- **中断频率**：1ms (1000Hz)
- **优先级**：抢占优先级0，子优先级1

**中断任务清单**：

```c
void TIM2_IRQHandler(void) {
    // 1. 软件定时器计数
    timerCount(&timer);
    
    // 2. 按键扫描 (发送模式专用)
    ReadKey();
    
    #if DEVICE_MODE==DEVICE_MODE_SEND
        // 3. 调试输出定时 (500ms)
        g_DebugTimer++;
        if(g_DebugTimer >= 500) {
            g_DebugTimer = 0;
            if(g_HasNewDebugData || g_HasNewTxData) {
                Debug_OutputData();
            }
        }
        
        // 4. LED闪烁定时 (50ms)
        g_BlinkTimer++;
        if(g_BlinkTimer >= 50) {
            g_BlinkTimer = 0;
            g_BlinkState = !g_BlinkState;
            PA_Blink_Process();
        }
    #endif
    
    TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
}
```

#### 软件定时器对象

**结构定义**：

```c
typedef struct _TIMER {
    uint16_t TimDownlinkUartTimeOutCount;     // UART超时计数器
    uint16_t TimDownlinkUartTimeOutAlarm;     // UART超时报警标志
    uint16_t TimUart1SendCount;               // 发送周期计数器
    uint16_t TimUart1SendAlarm;               // 发送周期报警标志
    
    void (*CloseTimer)(uint16_t *tim);
    void (*SetTimer)(uint16_t *tim, uint16_t N10ms);
    bool (*AceeptStatus)(uint16_t *time);
} TIMER;
```

**工作原理**：

```c
// 设置定时器
timer.SetTimer(&timer.TimUart1SendCount, 50);
// 内部实现: TimUart1SendCount = 50 + 1 = 51

// 每1ms自动递减
timerCount(&timer) {
    if(TimUart1SendCount > 1) {
        TimUart1SendCount--;           // 递减
    } else if(TimUart1SendCount == 1) {
        TimUart1SendCount = 0;         // 停止
        TimUart1SendAlarm = true;      // 触发报警
    }
}

// 主循环检测
if(timer.TimUart1SendAlarm == true) {
    timer.TimUart1SendAlarm = false;
    // 执行50ms周期任务
}
```

**定时器列表**：

| 定时器名称 | 周期 | 用途 | 工作模式 |
|-----------|------|------|---------|
| TimUart1SendCount | 50ms | 触发数据采集发送 | 仅发送模式 |
| TimDownlinkUartTimeOutCount | 5ms | UART接收超时检测 | 两种模式 |

---

### 2?? UART通信机制

#### UART1 (主通信接口)

**硬件配置**：
```c
波特率: 115200 bps
数据位: 8 bit
停止位: 1 bit
校验位: None
流控: None
引脚: PA9(TX), PA10(RX), PA11(RS485方向控制)
中断: 接收中断使能
```

**RS485方向控制**：

```c
发送前:
    GPIO_SetBits(GPIOA, GPIO_Pin_11);      // PA11=高电平
    USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);  // 关闭接收中断

发送中:
    逐字节发送，等待TC标志

发送后:
    GPIO_ResetBits(GPIOA, GPIO_Pin_11);    // PA11=低电平
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);   // 开启接收中断
```

**接收状态机**：

```c
void USART1_IRQHandler(void) {
    static uint8_t RxCount = 0;
    
    // 1. 超时检测 (5ms未收到数据)
    if(timer.TimDownlinkUartTimeOutAlarm == true) {
        RxCount = 0;  // 重新开始
    }
    
    // 2. 重置超时计时器
    timer.SetTimer(&timer.TimDownlinkUartTimeOutCount, 5);
    
    // 3. 接收数据
    Uart1_Struct.rx_data[RxCount] = USART_ReceiveData(USART1);
    RxCount++;
    
    // 4. 检查帧头
    if(Uart1_Struct.rx_data[0] != 0xAA) {
        RxCount = 0;  // 帧头错误，重新开始
        return;
    }
    
    // 5. 接收完成判断
    if(RxCount >= 14) {
        USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);
        Uart1_Struct.Receive_Complete = 1;
        RxCount = 0;
    }
}
```

#### UART3 (调试接口)

**用途**：
- 仅发送模式使用
- 输出调试信息，不干扰主通信
- 500ms输出一次

**输出内容示例**：

```
TX Data: [0xAA 0x01 0x20 0x00 0x08 0x00 0x08 0x00 0x04 0x00 0x04 0x00 0x3F 0x2A]
TX IO Status: B0=0x1 B1=0x20 B2=0x0
TX IO Bits: 0x2001 -> KEY1=0x1 PC4=0x0 PC5=0x0 PC6=0x0 bit8=0x0

RX Data: [0xAA 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x5C 0x1B]
RX IO Status: B0=0x1 B1=0x0 B2=0x0
RX IO Bits: 0x1 -> bit0=0x1 bit1=0x0 bit2=0x0 bit3=0x0 bit8=0x0 bit13=0x0
```

---

### 3?? CRC校验机制

**算法**：Modbus CRC-16
**多项式**：0xA001 (反向多项式)
**初始值**：0xFFFF
**异或值**：0x0000

**计算流程**：

```c
uint16_t Modbus_CRC_16(uint8_t *data, uint8_t len) {
    uint16_t crc = 0xFFFF;
    
    for(i = 0; i < len; i++) {
        crc ^= data[i];
        for(j = 0; j < 8; j++) {
            if(crc & 0x0001) {
                crc >>= 1;
                crc ^= 0xA001;
            } else {
                crc >>= 1;
            }
        }
    }
    
    return crc;
}
```

**校验范围**：
- 数据包的前12字节 ([0]-[11])
- CRC结果存储在 [12](低字节) 和 [13](高字节)

**校验失败处理**：

| 模式 | 处理方式 |
|------|---------|
| 发送模式 | 缓存错误信息，500ms后通过USART3输出<br>不影响后续发送 |
| 接收模式 | 丢弃数据包，不执行任何控制<br>不返回反馈 |

---

### 4?? 按键消抖机制

**消抖参数**：
- **ButtonOnFilter**: 5ms (未使用)
- **ButtonOffFilter**: 3ms (使用)
- **扫描周期**: 1ms (TIM2中断)

**状态机**：

```c
状态0 (等待按下):
    if(按键按下) {
        KeyPressTime = 0;
        转到状态1;
    }

状态1 (按键保持):
    KeyTime = KeyPressTime;
    if(按键松开) {
        转到状态2;
    }

状态2 (开始释放计时):
    ReleaseTime = 0;
    转到状态3;

状态3 (等待稳定):
    if(按键再次按下) {
        ReleaseTime = 0;
        转到状态1;
    }
    if(ReleaseTime > 3ms) {
        转到状态4;
    }

状态4 (确认有效按键):
    KeyValue = 1;  // 标记按键有效
    转到状态0;
```

---

## ? 典型应用场景

### 场景1：起重机遥控系统

**遥控手柄**：
- **KEY1**: 循环选择动作（上升/下降/前进/后退）
- **KEY5**: 循环选择速度（慢/中/快/紧急）
- **PB0**: 双手操作使能开关
- **摇杆1**: 左右移动速度
- **摇杆2**: 吊钩旋转角度
- **LED**: 显示限位、到位、故障等状态

**接收板**：
- **PC3-PC6**: 控制主要动作电机（需要PB0使能）
- **其他输出**: 指示灯、蜂鸣器、刹车释放
- **DAC**: 变频器速度控制
- **输入**: 上/下限位、过载检测、急停信号

### 场景2：AGV小车遥控

**遥控手柄**：
- **按键**: 前进/后退/左转/右转/停止
- **PB0**: 安全确认按钮
- **摇杆**: 速度和方向微调
- **LED**: 电池状态、充电状态、故障指示

**接收板**：
- **输出**: 电机驱动、转向控制、灯光
- **DAC**: 电机PWM速度控制
- **输入**: 碰撞检测、地磁传感器、充电座检测

### 场景3：液压系统控制

**遥控手柄**：
- **按键**: 各个液压缸的伸/缩控制
- **PB0**: 主压力使能
- **摇杆**: 比例阀开度控制
- **LED**: 压力状态、温度报警

**接收板**：
- **PC3-PC6**: 主要液压阀（需压力使能）
- **DAC**: 比例阀控制电压
- **输入**: 压力传感器、行程开关、温度开关

---

## ? 代码编译与烧录

### 编译遥控手柄固件

```c
// 1. 修改 User/inc/IOApp.h 第6行
#define DEVICE_MODE    DEVICE_MODE_SEND

// 2. Keil编译
Project → Build Target

// 3. 生成文件
Proj/Objects/sl8629V10-20170307.hex

// 4. 烧录到遥控手柄硬件
使用ST-Link或J-Link烧录器
```

### 编译接收板固件

```c
// 1. 修改 User/inc/IOApp.h 第6行
#define DEVICE_MODE    DEVICE_MODE_RECV

// 2. Keil编译
Project → Build Target

// 3. 生成文件
Proj/Objects/sl8629V10-20170307.hex

// 4. 烧录到接收板硬件
使用ST-Link或J-Link烧录器
```

### ?? 重要提醒

1. **不要烧录错误**：遥控手柄和接收板的固件不能互换！
2. **硬件差异**：两种硬件的PCB完全不同
3. **测试方法**：烧录后观察LED或调试输出确认工作模式
4. **版本管理**：建议生成两个不同名称的HEX文件

---

## ? 性能参数总结

| 参数 | 数值 | 说明 |
|------|------|------|
| **通信周期** | 50ms | 每秒20次数据交换 |
| **通信延迟** | <10ms | 从发送到接收完成 |
| **LED响应** | <10ms | 从接收到LED更新 |
| **输出响应** | <10ms | 从接收到继电器动作 |
| **超时检测** | 5ms | 字节间隔超时 |
| **按键扫描** | 1ms | 按键状态更新率 |
| **按键消抖** | 3ms | 释放后稳定时间 |
| **LED闪烁** | 10Hz | 50ms周期 |
| **调试输出** | 2Hz | 500ms周期 |
| **ADC采样** | 连续 | DMA自动搬运 |
| **CRC校验** | 100% | 每包都校验 |

---

## ?? 故障诊断

### 遥控手柄端

| 现象 | 可能原因 | 排查方法 |
|------|---------|---------|
| LED全不亮 | 电源故障/固件错误 | 检查电源，重新烧录 |
| LED全亮 | 固件烧错（接收板固件） | 烧录正确固件 |
| 按键无反应 | 按键硬件故障 | 检查GPIO连接 |
| LED不闪烁 | 定时器未工作 | 检查TIM2配置 |
| 无调试输出 | USART3故障 | 检查PB10/PB11 |

### 接收板端

| 现象 | 可能原因 | 排查方法 |
|------|---------|---------|
| 无输出 | 未接收到数据 | 检查通信连接 |
| 输出混乱 | 固件烧错（手柄固件） | 烧录正确固件 |
| PC3-PC6不工作 | PB0未使能 | 检查手柄PB0按键 |
| 反馈无数据 | UART发送故障 | 检查RS485方向控制 |
| CRC频繁错误 | 通信干扰/线路问题 | 检查RS485布线 |

---

---

# ? 代码逻辑修改要求（2025年11月10日）

1 修改PC3的控制逻辑：
   之前：PC3~PC6(key1控制的4个轮流切换的通道)激活通道，PB0使能
   修改目标：PC3~PC6激活通道（功能不变）变更为PB4(KEY17使能)，同时恢复PB0为普通按键，控制控制位13
2 修改手柄硬件的代码逻辑
   之前，

